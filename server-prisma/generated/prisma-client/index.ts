// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  attribute: (where?: AttributeWhereInput) => Promise<boolean>;
  attributeValue: (where?: AttributeValueWhereInput) => Promise<boolean>;
  audit: (where?: AuditWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  orderDetail: (where?: OrderDetailWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productAttribute: (where?: ProductAttributeWhereInput) => Promise<boolean>;
  productCategory: (where?: ProductCategoryWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  shipping: (where?: ShippingWhereInput) => Promise<boolean>;
  shippingRegion: (where?: ShippingRegionWhereInput) => Promise<boolean>;
  shoppingCart: (where?: ShoppingCartWhereInput) => Promise<boolean>;
  tax: (where?: TaxWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attribute: (where: AttributeWhereUniqueInput) => AttributeNullablePromise;
  attributes: (args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Attribute>;
  attributesConnection: (args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AttributeConnectionPromise;
  attributeValue: (
    where: AttributeValueWhereUniqueInput
  ) => AttributeValueNullablePromise;
  attributeValues: (args?: {
    where?: AttributeValueWhereInput;
    orderBy?: AttributeValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AttributeValue>;
  attributeValuesConnection: (args?: {
    where?: AttributeValueWhereInput;
    orderBy?: AttributeValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AttributeValueConnectionPromise;
  audit: (where: AuditWhereUniqueInput) => AuditNullablePromise;
  audits: (args?: {
    where?: AuditWhereInput;
    orderBy?: AuditOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Audit>;
  auditsConnection: (args?: {
    where?: AuditWhereInput;
    orderBy?: AuditOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuditConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  orderDetail: (
    where: OrderDetailWhereUniqueInput
  ) => OrderDetailNullablePromise;
  orderDetails: (args?: {
    where?: OrderDetailWhereInput;
    orderBy?: OrderDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderDetail>;
  orderDetailsConnection: (args?: {
    where?: OrderDetailWhereInput;
    orderBy?: OrderDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderDetailConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productAttribute: (
    where: ProductAttributeWhereUniqueInput
  ) => ProductAttributeNullablePromise;
  productAttributes: (args?: {
    where?: ProductAttributeWhereInput;
    orderBy?: ProductAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductAttribute>;
  productAttributesConnection: (args?: {
    where?: ProductAttributeWhereInput;
    orderBy?: ProductAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductAttributeConnectionPromise;
  productCategory: (
    where: ProductCategoryWhereUniqueInput
  ) => ProductCategoryNullablePromise;
  productCategories: (args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductCategory>;
  productCategoriesConnection: (args?: {
    where?: ProductCategoryWhereInput;
    orderBy?: ProductCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductCategoryConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewNullablePromise;
  reviews: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Review>;
  reviewsConnection: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewConnectionPromise;
  shipping: (where: ShippingWhereUniqueInput) => ShippingNullablePromise;
  shippings: (args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Shipping>;
  shippingsConnection: (args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShippingConnectionPromise;
  shippingRegion: (
    where: ShippingRegionWhereUniqueInput
  ) => ShippingRegionNullablePromise;
  shippingRegions: (args?: {
    where?: ShippingRegionWhereInput;
    orderBy?: ShippingRegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShippingRegion>;
  shippingRegionsConnection: (args?: {
    where?: ShippingRegionWhereInput;
    orderBy?: ShippingRegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShippingRegionConnectionPromise;
  shoppingCart: (
    where: ShoppingCartWhereUniqueInput
  ) => ShoppingCartNullablePromise;
  shoppingCarts: (args?: {
    where?: ShoppingCartWhereInput;
    orderBy?: ShoppingCartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShoppingCart>;
  shoppingCartsConnection: (args?: {
    where?: ShoppingCartWhereInput;
    orderBy?: ShoppingCartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShoppingCartConnectionPromise;
  tax: (where: TaxWhereUniqueInput) => TaxNullablePromise;
  taxes: (args?: {
    where?: TaxWhereInput;
    orderBy?: TaxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tax>;
  taxesConnection: (args?: {
    where?: TaxWhereInput;
    orderBy?: TaxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TaxConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttribute: (data: AttributeCreateInput) => AttributePromise;
  updateAttribute: (args: {
    data: AttributeUpdateInput;
    where: AttributeWhereUniqueInput;
  }) => AttributePromise;
  updateManyAttributes: (args: {
    data: AttributeUpdateManyMutationInput;
    where?: AttributeWhereInput;
  }) => BatchPayloadPromise;
  upsertAttribute: (args: {
    where: AttributeWhereUniqueInput;
    create: AttributeCreateInput;
    update: AttributeUpdateInput;
  }) => AttributePromise;
  deleteAttribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  deleteManyAttributes: (where?: AttributeWhereInput) => BatchPayloadPromise;
  createAttributeValue: (
    data: AttributeValueCreateInput
  ) => AttributeValuePromise;
  updateAttributeValue: (args: {
    data: AttributeValueUpdateInput;
    where: AttributeValueWhereUniqueInput;
  }) => AttributeValuePromise;
  updateManyAttributeValues: (args: {
    data: AttributeValueUpdateManyMutationInput;
    where?: AttributeValueWhereInput;
  }) => BatchPayloadPromise;
  upsertAttributeValue: (args: {
    where: AttributeValueWhereUniqueInput;
    create: AttributeValueCreateInput;
    update: AttributeValueUpdateInput;
  }) => AttributeValuePromise;
  deleteAttributeValue: (
    where: AttributeValueWhereUniqueInput
  ) => AttributeValuePromise;
  deleteManyAttributeValues: (
    where?: AttributeValueWhereInput
  ) => BatchPayloadPromise;
  createAudit: (data: AuditCreateInput) => AuditPromise;
  updateAudit: (args: {
    data: AuditUpdateInput;
    where: AuditWhereUniqueInput;
  }) => AuditPromise;
  updateManyAudits: (args: {
    data: AuditUpdateManyMutationInput;
    where?: AuditWhereInput;
  }) => BatchPayloadPromise;
  upsertAudit: (args: {
    where: AuditWhereUniqueInput;
    create: AuditCreateInput;
    update: AuditUpdateInput;
  }) => AuditPromise;
  deleteAudit: (where: AuditWhereUniqueInput) => AuditPromise;
  deleteManyAudits: (where?: AuditWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createOrderDetail: (data: OrderDetailCreateInput) => OrderDetailPromise;
  updateOrderDetail: (args: {
    data: OrderDetailUpdateInput;
    where: OrderDetailWhereUniqueInput;
  }) => OrderDetailPromise;
  updateManyOrderDetails: (args: {
    data: OrderDetailUpdateManyMutationInput;
    where?: OrderDetailWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderDetail: (args: {
    where: OrderDetailWhereUniqueInput;
    create: OrderDetailCreateInput;
    update: OrderDetailUpdateInput;
  }) => OrderDetailPromise;
  deleteOrderDetail: (where: OrderDetailWhereUniqueInput) => OrderDetailPromise;
  deleteManyOrderDetails: (
    where?: OrderDetailWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductAttribute: (
    data: ProductAttributeCreateInput
  ) => ProductAttributePromise;
  updateProductAttribute: (args: {
    data: ProductAttributeUpdateInput;
    where: ProductAttributeWhereUniqueInput;
  }) => ProductAttributePromise;
  upsertProductAttribute: (args: {
    where: ProductAttributeWhereUniqueInput;
    create: ProductAttributeCreateInput;
    update: ProductAttributeUpdateInput;
  }) => ProductAttributePromise;
  deleteProductAttribute: (
    where: ProductAttributeWhereUniqueInput
  ) => ProductAttributePromise;
  deleteManyProductAttributes: (
    where?: ProductAttributeWhereInput
  ) => BatchPayloadPromise;
  createProductCategory: (
    data: ProductCategoryCreateInput
  ) => ProductCategoryPromise;
  updateProductCategory: (args: {
    data: ProductCategoryUpdateInput;
    where: ProductCategoryWhereUniqueInput;
  }) => ProductCategoryPromise;
  upsertProductCategory: (args: {
    where: ProductCategoryWhereUniqueInput;
    create: ProductCategoryCreateInput;
    update: ProductCategoryUpdateInput;
  }) => ProductCategoryPromise;
  deleteProductCategory: (
    where: ProductCategoryWhereUniqueInput
  ) => ProductCategoryPromise;
  deleteManyProductCategories: (
    where?: ProductCategoryWhereInput
  ) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (args: {
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
  }) => ReviewPromise;
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertReview: (args: {
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
  }) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createShipping: (data: ShippingCreateInput) => ShippingPromise;
  updateShipping: (args: {
    data: ShippingUpdateInput;
    where: ShippingWhereUniqueInput;
  }) => ShippingPromise;
  updateManyShippings: (args: {
    data: ShippingUpdateManyMutationInput;
    where?: ShippingWhereInput;
  }) => BatchPayloadPromise;
  upsertShipping: (args: {
    where: ShippingWhereUniqueInput;
    create: ShippingCreateInput;
    update: ShippingUpdateInput;
  }) => ShippingPromise;
  deleteShipping: (where: ShippingWhereUniqueInput) => ShippingPromise;
  deleteManyShippings: (where?: ShippingWhereInput) => BatchPayloadPromise;
  createShippingRegion: (
    data: ShippingRegionCreateInput
  ) => ShippingRegionPromise;
  updateShippingRegion: (args: {
    data: ShippingRegionUpdateInput;
    where: ShippingRegionWhereUniqueInput;
  }) => ShippingRegionPromise;
  updateManyShippingRegions: (args: {
    data: ShippingRegionUpdateManyMutationInput;
    where?: ShippingRegionWhereInput;
  }) => BatchPayloadPromise;
  upsertShippingRegion: (args: {
    where: ShippingRegionWhereUniqueInput;
    create: ShippingRegionCreateInput;
    update: ShippingRegionUpdateInput;
  }) => ShippingRegionPromise;
  deleteShippingRegion: (
    where: ShippingRegionWhereUniqueInput
  ) => ShippingRegionPromise;
  deleteManyShippingRegions: (
    where?: ShippingRegionWhereInput
  ) => BatchPayloadPromise;
  createShoppingCart: (data: ShoppingCartCreateInput) => ShoppingCartPromise;
  updateShoppingCart: (args: {
    data: ShoppingCartUpdateInput;
    where: ShoppingCartWhereUniqueInput;
  }) => ShoppingCartPromise;
  updateManyShoppingCarts: (args: {
    data: ShoppingCartUpdateManyMutationInput;
    where?: ShoppingCartWhereInput;
  }) => BatchPayloadPromise;
  upsertShoppingCart: (args: {
    where: ShoppingCartWhereUniqueInput;
    create: ShoppingCartCreateInput;
    update: ShoppingCartUpdateInput;
  }) => ShoppingCartPromise;
  deleteShoppingCart: (
    where: ShoppingCartWhereUniqueInput
  ) => ShoppingCartPromise;
  deleteManyShoppingCarts: (
    where?: ShoppingCartWhereInput
  ) => BatchPayloadPromise;
  createTax: (data: TaxCreateInput) => TaxPromise;
  updateTax: (args: {
    data: TaxUpdateInput;
    where: TaxWhereUniqueInput;
  }) => TaxPromise;
  updateManyTaxes: (args: {
    data: TaxUpdateManyMutationInput;
    where?: TaxWhereInput;
  }) => BatchPayloadPromise;
  upsertTax: (args: {
    where: TaxWhereUniqueInput;
    create: TaxCreateInput;
    update: TaxUpdateInput;
  }) => TaxPromise;
  deleteTax: (where: TaxWhereUniqueInput) => TaxPromise;
  deleteManyTaxes: (where?: TaxWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attribute: (
    where?: AttributeSubscriptionWhereInput
  ) => AttributeSubscriptionPayloadSubscription;
  attributeValue: (
    where?: AttributeValueSubscriptionWhereInput
  ) => AttributeValueSubscriptionPayloadSubscription;
  audit: (
    where?: AuditSubscriptionWhereInput
  ) => AuditSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  orderDetail: (
    where?: OrderDetailSubscriptionWhereInput
  ) => OrderDetailSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productAttribute: (
    where?: ProductAttributeSubscriptionWhereInput
  ) => ProductAttributeSubscriptionPayloadSubscription;
  productCategory: (
    where?: ProductCategorySubscriptionWhereInput
  ) => ProductCategorySubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  shipping: (
    where?: ShippingSubscriptionWhereInput
  ) => ShippingSubscriptionPayloadSubscription;
  shippingRegion: (
    where?: ShippingRegionSubscriptionWhereInput
  ) => ShippingRegionSubscriptionPayloadSubscription;
  shoppingCart: (
    where?: ShoppingCartSubscriptionWhereInput
  ) => ShoppingCartSubscriptionPayloadSubscription;
  tax: (
    where?: TaxSubscriptionWhereInput
  ) => TaxSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProductAttributeOrderByInput = "id_ASC" | "id_DESC";

export type AuditOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdOn_ASC"
  | "createdOn_DESC"
  | "message_ASC"
  | "message_DESC"
  | "code_ASC"
  | "code_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "price_ASC"
  | "price_DESC"
  | "discountedPrice_ASC"
  | "discountedPrice_DESC"
  | "image_ASC"
  | "image_DESC"
  | "image2_ASC"
  | "image2_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "display_ASC"
  | "display_DESC";

export type TaxOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "taxType_ASC"
  | "taxType_DESC"
  | "taxPercentage_ASC"
  | "taxPercentage_DESC";

export type OrderDetailOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "attributes_ASC"
  | "attributes_DESC"
  | "productName_ASC"
  | "productName_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "unitCost_ASC"
  | "unitCost_DESC";

export type AttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "totalAmount_ASC"
  | "totalAmount_DESC"
  | "createdOn_ASC"
  | "createdOn_DESC"
  | "shippedOn_ASC"
  | "shippedOn_DESC"
  | "status_ASC"
  | "status_DESC"
  | "comments_ASC"
  | "comments_DESC"
  | "authCode_ASC"
  | "authCode_DESC"
  | "reference_ASC"
  | "reference_DESC";

export type ShippingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "shippingType_ASC"
  | "shippingType_DESC"
  | "shippingCost_ASC"
  | "shippingCost_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "creditCard_ASC"
  | "creditCard_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "region_ASC"
  | "region_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "country_ASC"
  | "country_DESC"
  | "dayPhone_ASC"
  | "dayPhone_DESC"
  | "evePhone_ASC"
  | "evePhone_DESC"
  | "mobPhone_ASC"
  | "mobPhone_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type AttributeValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "review_ASC"
  | "review_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "created_On_ASC"
  | "created_On_DESC";

export type ShippingRegionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "shippingRegion_ASC"
  | "shippingRegion_DESC";

export type ShoppingCartOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "cartId_ASC"
  | "cartId_DESC"
  | "attributes_ASC"
  | "attributes_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "buyNow_ASC"
  | "buyNow_DESC"
  | "addedOn_ASC"
  | "addedOn_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ProductCategoryOrderByInput = "id_ASC" | "id_DESC";

export interface AttributeUpdateDataInput {
  name?: Maybe<String>;
}

export type AttributeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface OrderDetailUpdateManyMutationInput {
  attributes?: Maybe<String>;
  productName?: Maybe<String>;
  quantity?: Maybe<Int>;
  unitCost?: Maybe<Float>;
}

export interface ShippingUpsertNestedInput {
  update: ShippingUpdateDataInput;
  create: ShippingCreateInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ShippingCreateOneInput {
  create?: Maybe<ShippingCreateInput>;
  connect?: Maybe<ShippingWhereUniqueInput>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ShoppingCartSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShoppingCartWhereInput>;
  AND?: Maybe<
    ShoppingCartSubscriptionWhereInput[] | ShoppingCartSubscriptionWhereInput
  >;
  OR?: Maybe<
    ShoppingCartSubscriptionWhereInput[] | ShoppingCartSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ShoppingCartSubscriptionWhereInput[] | ShoppingCartSubscriptionWhereInput
  >;
}

export interface ReviewWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  customer?: Maybe<CustomerWhereInput>;
  product?: Maybe<ProductWhereInput>;
  review?: Maybe<String>;
  review_not?: Maybe<String>;
  review_in?: Maybe<String[] | String>;
  review_not_in?: Maybe<String[] | String>;
  review_lt?: Maybe<String>;
  review_lte?: Maybe<String>;
  review_gt?: Maybe<String>;
  review_gte?: Maybe<String>;
  review_contains?: Maybe<String>;
  review_not_contains?: Maybe<String>;
  review_starts_with?: Maybe<String>;
  review_not_starts_with?: Maybe<String>;
  review_ends_with?: Maybe<String>;
  review_not_ends_with?: Maybe<String>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  created_On?: Maybe<String>;
  created_On_not?: Maybe<String>;
  created_On_in?: Maybe<String[] | String>;
  created_On_not_in?: Maybe<String[] | String>;
  created_On_lt?: Maybe<String>;
  created_On_lte?: Maybe<String>;
  created_On_gt?: Maybe<String>;
  created_On_gte?: Maybe<String>;
  created_On_contains?: Maybe<String>;
  created_On_not_contains?: Maybe<String>;
  created_On_starts_with?: Maybe<String>;
  created_On_not_starts_with?: Maybe<String>;
  created_On_ends_with?: Maybe<String>;
  created_On_not_ends_with?: Maybe<String>;
  AND?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  OR?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  NOT?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
}

export interface ShippingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShippingWhereInput>;
  AND?: Maybe<
    ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput
  >;
  OR?: Maybe<ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput>;
  NOT?: Maybe<
    ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput
  >;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  price?: Maybe<Float>;
  discountedPrice?: Maybe<Float>;
  image?: Maybe<String>;
  image2?: Maybe<String>;
  thumbnail?: Maybe<String>;
  display?: Maybe<Int>;
}

export interface AuditWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  order?: Maybe<OrderWhereInput>;
  createdOn?: Maybe<String>;
  createdOn_not?: Maybe<String>;
  createdOn_in?: Maybe<String[] | String>;
  createdOn_not_in?: Maybe<String[] | String>;
  createdOn_lt?: Maybe<String>;
  createdOn_lte?: Maybe<String>;
  createdOn_gt?: Maybe<String>;
  createdOn_gte?: Maybe<String>;
  createdOn_contains?: Maybe<String>;
  createdOn_not_contains?: Maybe<String>;
  createdOn_starts_with?: Maybe<String>;
  createdOn_not_starts_with?: Maybe<String>;
  createdOn_ends_with?: Maybe<String>;
  createdOn_not_ends_with?: Maybe<String>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  code?: Maybe<Int>;
  code_not?: Maybe<Int>;
  code_in?: Maybe<Int[] | Int>;
  code_not_in?: Maybe<Int[] | Int>;
  code_lt?: Maybe<Int>;
  code_lte?: Maybe<Int>;
  code_gt?: Maybe<Int>;
  code_gte?: Maybe<Int>;
  AND?: Maybe<AuditWhereInput[] | AuditWhereInput>;
  OR?: Maybe<AuditWhereInput[] | AuditWhereInput>;
  NOT?: Maybe<AuditWhereInput[] | AuditWhereInput>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  creditCard?: Maybe<String>;
  creditCard_not?: Maybe<String>;
  creditCard_in?: Maybe<String[] | String>;
  creditCard_not_in?: Maybe<String[] | String>;
  creditCard_lt?: Maybe<String>;
  creditCard_lte?: Maybe<String>;
  creditCard_gt?: Maybe<String>;
  creditCard_gte?: Maybe<String>;
  creditCard_contains?: Maybe<String>;
  creditCard_not_contains?: Maybe<String>;
  creditCard_starts_with?: Maybe<String>;
  creditCard_not_starts_with?: Maybe<String>;
  creditCard_ends_with?: Maybe<String>;
  creditCard_not_ends_with?: Maybe<String>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  region?: Maybe<String>;
  region_not?: Maybe<String>;
  region_in?: Maybe<String[] | String>;
  region_not_in?: Maybe<String[] | String>;
  region_lt?: Maybe<String>;
  region_lte?: Maybe<String>;
  region_gt?: Maybe<String>;
  region_gte?: Maybe<String>;
  region_contains?: Maybe<String>;
  region_not_contains?: Maybe<String>;
  region_starts_with?: Maybe<String>;
  region_not_starts_with?: Maybe<String>;
  region_ends_with?: Maybe<String>;
  region_not_ends_with?: Maybe<String>;
  postalCode?: Maybe<String>;
  postalCode_not?: Maybe<String>;
  postalCode_in?: Maybe<String[] | String>;
  postalCode_not_in?: Maybe<String[] | String>;
  postalCode_lt?: Maybe<String>;
  postalCode_lte?: Maybe<String>;
  postalCode_gt?: Maybe<String>;
  postalCode_gte?: Maybe<String>;
  postalCode_contains?: Maybe<String>;
  postalCode_not_contains?: Maybe<String>;
  postalCode_starts_with?: Maybe<String>;
  postalCode_not_starts_with?: Maybe<String>;
  postalCode_ends_with?: Maybe<String>;
  postalCode_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  shippingRegion?: Maybe<ShippingRegionWhereInput>;
  dayPhone?: Maybe<String>;
  dayPhone_not?: Maybe<String>;
  dayPhone_in?: Maybe<String[] | String>;
  dayPhone_not_in?: Maybe<String[] | String>;
  dayPhone_lt?: Maybe<String>;
  dayPhone_lte?: Maybe<String>;
  dayPhone_gt?: Maybe<String>;
  dayPhone_gte?: Maybe<String>;
  dayPhone_contains?: Maybe<String>;
  dayPhone_not_contains?: Maybe<String>;
  dayPhone_starts_with?: Maybe<String>;
  dayPhone_not_starts_with?: Maybe<String>;
  dayPhone_ends_with?: Maybe<String>;
  dayPhone_not_ends_with?: Maybe<String>;
  evePhone?: Maybe<String>;
  evePhone_not?: Maybe<String>;
  evePhone_in?: Maybe<String[] | String>;
  evePhone_not_in?: Maybe<String[] | String>;
  evePhone_lt?: Maybe<String>;
  evePhone_lte?: Maybe<String>;
  evePhone_gt?: Maybe<String>;
  evePhone_gte?: Maybe<String>;
  evePhone_contains?: Maybe<String>;
  evePhone_not_contains?: Maybe<String>;
  evePhone_starts_with?: Maybe<String>;
  evePhone_not_starts_with?: Maybe<String>;
  evePhone_ends_with?: Maybe<String>;
  evePhone_not_ends_with?: Maybe<String>;
  mobPhone?: Maybe<String>;
  mobPhone_not?: Maybe<String>;
  mobPhone_in?: Maybe<String[] | String>;
  mobPhone_not_in?: Maybe<String[] | String>;
  mobPhone_lt?: Maybe<String>;
  mobPhone_lte?: Maybe<String>;
  mobPhone_gt?: Maybe<String>;
  mobPhone_gte?: Maybe<String>;
  mobPhone_contains?: Maybe<String>;
  mobPhone_not_contains?: Maybe<String>;
  mobPhone_starts_with?: Maybe<String>;
  mobPhone_not_starts_with?: Maybe<String>;
  mobPhone_ends_with?: Maybe<String>;
  mobPhone_not_ends_with?: Maybe<String>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface OrderDetailUpdateInput {
  order?: Maybe<OrderUpdateOneRequiredInput>;
  product?: Maybe<ProductUpdateOneRequiredInput>;
  attributes?: Maybe<String>;
  productName?: Maybe<String>;
  quantity?: Maybe<Int>;
  unitCost?: Maybe<Float>;
}

export interface ShippingWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  shippingType?: Maybe<String>;
  shippingType_not?: Maybe<String>;
  shippingType_in?: Maybe<String[] | String>;
  shippingType_not_in?: Maybe<String[] | String>;
  shippingType_lt?: Maybe<String>;
  shippingType_lte?: Maybe<String>;
  shippingType_gt?: Maybe<String>;
  shippingType_gte?: Maybe<String>;
  shippingType_contains?: Maybe<String>;
  shippingType_not_contains?: Maybe<String>;
  shippingType_starts_with?: Maybe<String>;
  shippingType_not_starts_with?: Maybe<String>;
  shippingType_ends_with?: Maybe<String>;
  shippingType_not_ends_with?: Maybe<String>;
  shippingCost?: Maybe<Float>;
  shippingCost_not?: Maybe<Float>;
  shippingCost_in?: Maybe<Float[] | Float>;
  shippingCost_not_in?: Maybe<Float[] | Float>;
  shippingCost_lt?: Maybe<Float>;
  shippingCost_lte?: Maybe<Float>;
  shippingCost_gt?: Maybe<Float>;
  shippingCost_gte?: Maybe<Float>;
  shippingRegion?: Maybe<ShippingRegionWhereInput>;
  AND?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
  OR?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
  NOT?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
}

export interface ProductCreateInput {
  id?: Maybe<Int>;
  name: String;
  description: String;
  price: Float;
  discountedPrice: Float;
  image?: Maybe<String>;
  image2?: Maybe<String>;
  thumbnail?: Maybe<String>;
  display: Int;
}

export type AuditWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ShippingWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ProductAttributeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductAttributeWhereInput>;
  AND?: Maybe<
    | ProductAttributeSubscriptionWhereInput[]
    | ProductAttributeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductAttributeSubscriptionWhereInput[]
    | ProductAttributeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductAttributeSubscriptionWhereInput[]
    | ProductAttributeSubscriptionWhereInput
  >;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface OrderDetailCreateInput {
  id?: Maybe<Int>;
  order: OrderCreateOneInput;
  product: ProductCreateOneInput;
  attributes: String;
  productName: String;
  quantity: Int;
  unitCost: Float;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface OrderUpdateManyMutationInput {
  totalAmount?: Maybe<Float>;
  createdOn?: Maybe<String>;
  shippedOn?: Maybe<String>;
  status?: Maybe<Int>;
  comments?: Maybe<String>;
  authCode?: Maybe<String>;
  reference?: Maybe<String>;
}

export interface DepartmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export interface OrderUpdateInput {
  totalAmount?: Maybe<Float>;
  createdOn?: Maybe<String>;
  shippedOn?: Maybe<String>;
  status?: Maybe<Int>;
  comments?: Maybe<String>;
  customer?: Maybe<CustomerUpdateOneInput>;
  authCode?: Maybe<String>;
  reference?: Maybe<String>;
  shipping?: Maybe<ShippingUpdateOneInput>;
  tax?: Maybe<TaxUpdateOneInput>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export type ShippingRegionWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface AuditSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuditWhereInput>;
  AND?: Maybe<AuditSubscriptionWhereInput[] | AuditSubscriptionWhereInput>;
  OR?: Maybe<AuditSubscriptionWhereInput[] | AuditSubscriptionWhereInput>;
  NOT?: Maybe<AuditSubscriptionWhereInput[] | AuditSubscriptionWhereInput>;
}

export interface DepartmentUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface AttributeValueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AttributeValueWhereInput>;
  AND?: Maybe<
    | AttributeValueSubscriptionWhereInput[]
    | AttributeValueSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AttributeValueSubscriptionWhereInput[]
    | AttributeValueSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AttributeValueSubscriptionWhereInput[]
    | AttributeValueSubscriptionWhereInput
  >;
}

export interface DepartmentUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface TaxUpdateManyMutationInput {
  taxType?: Maybe<String>;
  taxPercentage?: Maybe<Float>;
}

export interface CustomerUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  creditCard?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
  dayPhone?: Maybe<String>;
  evePhone?: Maybe<String>;
  mobPhone?: Maybe<String>;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface CustomerUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  creditCard?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
  shippingRegion?: Maybe<ShippingRegionUpdateOneRequiredInput>;
  dayPhone?: Maybe<String>;
  evePhone?: Maybe<String>;
  mobPhone?: Maybe<String>;
}

export interface ShoppingCartUpdateInput {
  cartId?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredInput>;
  attributes?: Maybe<String>;
  quantity?: Maybe<Int>;
  buyNow?: Maybe<Boolean>;
  addedOn?: Maybe<String>;
}

export type ShoppingCartWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ShippingRegionUpdateManyMutationInput {
  shippingRegion?: Maybe<String>;
}

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface AttributeValueWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  attribute?: Maybe<AttributeWhereInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<AttributeValueWhereInput[] | AttributeValueWhereInput>;
  OR?: Maybe<AttributeValueWhereInput[] | AttributeValueWhereInput>;
  NOT?: Maybe<AttributeValueWhereInput[] | AttributeValueWhereInput>;
}

export interface ShoppingCartWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  cartId?: Maybe<String>;
  cartId_not?: Maybe<String>;
  cartId_in?: Maybe<String[] | String>;
  cartId_not_in?: Maybe<String[] | String>;
  cartId_lt?: Maybe<String>;
  cartId_lte?: Maybe<String>;
  cartId_gt?: Maybe<String>;
  cartId_gte?: Maybe<String>;
  cartId_contains?: Maybe<String>;
  cartId_not_contains?: Maybe<String>;
  cartId_starts_with?: Maybe<String>;
  cartId_not_starts_with?: Maybe<String>;
  cartId_ends_with?: Maybe<String>;
  cartId_not_ends_with?: Maybe<String>;
  product?: Maybe<ProductWhereInput>;
  attributes?: Maybe<String>;
  attributes_not?: Maybe<String>;
  attributes_in?: Maybe<String[] | String>;
  attributes_not_in?: Maybe<String[] | String>;
  attributes_lt?: Maybe<String>;
  attributes_lte?: Maybe<String>;
  attributes_gt?: Maybe<String>;
  attributes_gte?: Maybe<String>;
  attributes_contains?: Maybe<String>;
  attributes_not_contains?: Maybe<String>;
  attributes_starts_with?: Maybe<String>;
  attributes_not_starts_with?: Maybe<String>;
  attributes_ends_with?: Maybe<String>;
  attributes_not_ends_with?: Maybe<String>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  buyNow?: Maybe<Boolean>;
  buyNow_not?: Maybe<Boolean>;
  addedOn?: Maybe<String>;
  addedOn_not?: Maybe<String>;
  addedOn_in?: Maybe<String[] | String>;
  addedOn_not_in?: Maybe<String[] | String>;
  addedOn_lt?: Maybe<String>;
  addedOn_lte?: Maybe<String>;
  addedOn_gt?: Maybe<String>;
  addedOn_gte?: Maybe<String>;
  addedOn_contains?: Maybe<String>;
  addedOn_not_contains?: Maybe<String>;
  addedOn_starts_with?: Maybe<String>;
  addedOn_not_starts_with?: Maybe<String>;
  addedOn_ends_with?: Maybe<String>;
  addedOn_not_ends_with?: Maybe<String>;
  AND?: Maybe<ShoppingCartWhereInput[] | ShoppingCartWhereInput>;
  OR?: Maybe<ShoppingCartWhereInput[] | ShoppingCartWhereInput>;
  NOT?: Maybe<ShoppingCartWhereInput[] | ShoppingCartWhereInput>;
}

export interface ShippingUpdateManyMutationInput {
  shippingType?: Maybe<String>;
  shippingCost?: Maybe<Float>;
}

export interface AttributeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<AttributeWhereInput[] | AttributeWhereInput>;
  OR?: Maybe<AttributeWhereInput[] | AttributeWhereInput>;
  NOT?: Maybe<AttributeWhereInput[] | AttributeWhereInput>;
}

export type OrderDetailWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DepartmentUpsertNestedInput {
  update: DepartmentUpdateDataInput;
  create: DepartmentCreateInput;
}

export interface CustomerUpdateOneRequiredInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface DepartmentUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ProductWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  discountedPrice?: Maybe<Float>;
  discountedPrice_not?: Maybe<Float>;
  discountedPrice_in?: Maybe<Float[] | Float>;
  discountedPrice_not_in?: Maybe<Float[] | Float>;
  discountedPrice_lt?: Maybe<Float>;
  discountedPrice_lte?: Maybe<Float>;
  discountedPrice_gt?: Maybe<Float>;
  discountedPrice_gte?: Maybe<Float>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  image2?: Maybe<String>;
  image2_not?: Maybe<String>;
  image2_in?: Maybe<String[] | String>;
  image2_not_in?: Maybe<String[] | String>;
  image2_lt?: Maybe<String>;
  image2_lte?: Maybe<String>;
  image2_gt?: Maybe<String>;
  image2_gte?: Maybe<String>;
  image2_contains?: Maybe<String>;
  image2_not_contains?: Maybe<String>;
  image2_starts_with?: Maybe<String>;
  image2_not_starts_with?: Maybe<String>;
  image2_ends_with?: Maybe<String>;
  image2_not_ends_with?: Maybe<String>;
  thumbnail?: Maybe<String>;
  thumbnail_not?: Maybe<String>;
  thumbnail_in?: Maybe<String[] | String>;
  thumbnail_not_in?: Maybe<String[] | String>;
  thumbnail_lt?: Maybe<String>;
  thumbnail_lte?: Maybe<String>;
  thumbnail_gt?: Maybe<String>;
  thumbnail_gte?: Maybe<String>;
  thumbnail_contains?: Maybe<String>;
  thumbnail_not_contains?: Maybe<String>;
  thumbnail_starts_with?: Maybe<String>;
  thumbnail_not_starts_with?: Maybe<String>;
  thumbnail_ends_with?: Maybe<String>;
  thumbnail_not_ends_with?: Maybe<String>;
  display?: Maybe<Int>;
  display_not?: Maybe<Int>;
  display_in?: Maybe<Int[] | Int>;
  display_not_in?: Maybe<Int[] | Int>;
  display_lt?: Maybe<Int>;
  display_lte?: Maybe<Int>;
  display_gt?: Maybe<Int>;
  display_gte?: Maybe<Int>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface DepartmentUpdateOneRequiredInput {
  create?: Maybe<DepartmentCreateInput>;
  update?: Maybe<DepartmentUpdateDataInput>;
  upsert?: Maybe<DepartmentUpsertNestedInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface ReviewCreateInput {
  id?: Maybe<Int>;
  customer: CustomerCreateOneInput;
  product: ProductCreateOneInput;
  review: String;
  rating: Int;
  created_On: String;
}

export type TaxWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface CategoryUpdateDataInput {
  department?: Maybe<DepartmentUpdateOneRequiredInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CategoryUpdateInput {
  department?: Maybe<DepartmentUpdateOneRequiredInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export type AttributeValueWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DepartmentCreateInput {
  id?: Maybe<Int>;
  name: String;
  description?: Maybe<String>;
}

export interface ProductCategoryUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
}

export interface DepartmentCreateOneInput {
  create?: Maybe<DepartmentCreateInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export type ProductAttributeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface CategoryCreateInput {
  id?: Maybe<Int>;
  department: DepartmentCreateOneInput;
  name: String;
  description?: Maybe<String>;
}

export interface ProductAttributeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  product?: Maybe<ProductWhereInput>;
  attributeValue?: Maybe<AttributeValueWhereInput>;
  AND?: Maybe<ProductAttributeWhereInput[] | ProductAttributeWhereInput>;
  OR?: Maybe<ProductAttributeWhereInput[] | ProductAttributeWhereInput>;
  NOT?: Maybe<ProductAttributeWhereInput[] | ProductAttributeWhereInput>;
}

export interface AuditUpdateManyMutationInput {
  createdOn?: Maybe<String>;
  message?: Maybe<String>;
  code?: Maybe<Int>;
}

export interface AttributeValueUpdateDataInput {
  attribute?: Maybe<AttributeUpdateOneRequiredInput>;
  value?: Maybe<String>;
}

export interface ProductAttributeUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  attributeValue?: Maybe<AttributeValueUpdateOneRequiredInput>;
}

export interface AttributeValueCreateOneInput {
  create?: Maybe<AttributeValueCreateInput>;
  connect?: Maybe<AttributeValueWhereUniqueInput>;
}

export interface AttributeCreateInput {
  id?: Maybe<Int>;
  name: String;
}

export interface ProductAttributeCreateInput {
  id?: Maybe<Int>;
  product: ProductCreateOneInput;
  attributeValue: AttributeValueCreateOneInput;
}

export interface AttributeUpdateInput {
  name?: Maybe<String>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  price?: Maybe<Float>;
  discountedPrice?: Maybe<Float>;
  image?: Maybe<String>;
  image2?: Maybe<String>;
  thumbnail?: Maybe<String>;
  display?: Maybe<Int>;
}

export interface AttributeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ShippingRegionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShippingRegionWhereInput>;
  AND?: Maybe<
    | ShippingRegionSubscriptionWhereInput[]
    | ShippingRegionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ShippingRegionSubscriptionWhereInput[]
    | ShippingRegionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ShippingRegionSubscriptionWhereInput[]
    | ShippingRegionSubscriptionWhereInput
  >;
}

export interface OrderUpsertNestedInput {
  update: OrderUpdateDataInput;
  create: OrderCreateInput;
}

export interface OrderWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  totalAmount?: Maybe<Float>;
  totalAmount_not?: Maybe<Float>;
  totalAmount_in?: Maybe<Float[] | Float>;
  totalAmount_not_in?: Maybe<Float[] | Float>;
  totalAmount_lt?: Maybe<Float>;
  totalAmount_lte?: Maybe<Float>;
  totalAmount_gt?: Maybe<Float>;
  totalAmount_gte?: Maybe<Float>;
  createdOn?: Maybe<String>;
  createdOn_not?: Maybe<String>;
  createdOn_in?: Maybe<String[] | String>;
  createdOn_not_in?: Maybe<String[] | String>;
  createdOn_lt?: Maybe<String>;
  createdOn_lte?: Maybe<String>;
  createdOn_gt?: Maybe<String>;
  createdOn_gte?: Maybe<String>;
  createdOn_contains?: Maybe<String>;
  createdOn_not_contains?: Maybe<String>;
  createdOn_starts_with?: Maybe<String>;
  createdOn_not_starts_with?: Maybe<String>;
  createdOn_ends_with?: Maybe<String>;
  createdOn_not_ends_with?: Maybe<String>;
  shippedOn?: Maybe<String>;
  shippedOn_not?: Maybe<String>;
  shippedOn_in?: Maybe<String[] | String>;
  shippedOn_not_in?: Maybe<String[] | String>;
  shippedOn_lt?: Maybe<String>;
  shippedOn_lte?: Maybe<String>;
  shippedOn_gt?: Maybe<String>;
  shippedOn_gte?: Maybe<String>;
  shippedOn_contains?: Maybe<String>;
  shippedOn_not_contains?: Maybe<String>;
  shippedOn_starts_with?: Maybe<String>;
  shippedOn_not_starts_with?: Maybe<String>;
  shippedOn_ends_with?: Maybe<String>;
  shippedOn_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  comments?: Maybe<String>;
  comments_not?: Maybe<String>;
  comments_in?: Maybe<String[] | String>;
  comments_not_in?: Maybe<String[] | String>;
  comments_lt?: Maybe<String>;
  comments_lte?: Maybe<String>;
  comments_gt?: Maybe<String>;
  comments_gte?: Maybe<String>;
  comments_contains?: Maybe<String>;
  comments_not_contains?: Maybe<String>;
  comments_starts_with?: Maybe<String>;
  comments_not_starts_with?: Maybe<String>;
  comments_ends_with?: Maybe<String>;
  comments_not_ends_with?: Maybe<String>;
  customer?: Maybe<CustomerWhereInput>;
  authCode?: Maybe<String>;
  authCode_not?: Maybe<String>;
  authCode_in?: Maybe<String[] | String>;
  authCode_not_in?: Maybe<String[] | String>;
  authCode_lt?: Maybe<String>;
  authCode_lte?: Maybe<String>;
  authCode_gt?: Maybe<String>;
  authCode_gte?: Maybe<String>;
  authCode_contains?: Maybe<String>;
  authCode_not_contains?: Maybe<String>;
  authCode_starts_with?: Maybe<String>;
  authCode_not_starts_with?: Maybe<String>;
  authCode_ends_with?: Maybe<String>;
  authCode_not_ends_with?: Maybe<String>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  shipping?: Maybe<ShippingWhereInput>;
  tax?: Maybe<TaxWhereInput>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface TaxUpsertNestedInput {
  update: TaxUpdateDataInput;
  create: TaxCreateInput;
}

export interface TaxWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  taxType?: Maybe<String>;
  taxType_not?: Maybe<String>;
  taxType_in?: Maybe<String[] | String>;
  taxType_not_in?: Maybe<String[] | String>;
  taxType_lt?: Maybe<String>;
  taxType_lte?: Maybe<String>;
  taxType_gt?: Maybe<String>;
  taxType_gte?: Maybe<String>;
  taxType_contains?: Maybe<String>;
  taxType_not_contains?: Maybe<String>;
  taxType_starts_with?: Maybe<String>;
  taxType_not_starts_with?: Maybe<String>;
  taxType_ends_with?: Maybe<String>;
  taxType_not_ends_with?: Maybe<String>;
  taxPercentage?: Maybe<Float>;
  taxPercentage_not?: Maybe<Float>;
  taxPercentage_in?: Maybe<Float[] | Float>;
  taxPercentage_not_in?: Maybe<Float[] | Float>;
  taxPercentage_lt?: Maybe<Float>;
  taxPercentage_lte?: Maybe<Float>;
  taxPercentage_gt?: Maybe<Float>;
  taxPercentage_gte?: Maybe<Float>;
  AND?: Maybe<TaxWhereInput[] | TaxWhereInput>;
  OR?: Maybe<TaxWhereInput[] | TaxWhereInput>;
  NOT?: Maybe<TaxWhereInput[] | TaxWhereInput>;
}

export interface AttributeValueCreateInput {
  id?: Maybe<Int>;
  attribute: AttributeCreateOneInput;
  value: String;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface AttributeCreateOneInput {
  create?: Maybe<AttributeCreateInput>;
  connect?: Maybe<AttributeWhereUniqueInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  department?: Maybe<DepartmentWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface AttributeValueUpdateInput {
  attribute?: Maybe<AttributeUpdateOneRequiredInput>;
  value?: Maybe<String>;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface AttributeUpdateOneRequiredInput {
  create?: Maybe<AttributeCreateInput>;
  update?: Maybe<AttributeUpdateDataInput>;
  upsert?: Maybe<AttributeUpsertNestedInput>;
  connect?: Maybe<AttributeWhereUniqueInput>;
}

export interface AttributeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AttributeWhereInput>;
  AND?: Maybe<
    AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput
  >;
  OR?: Maybe<
    AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput
  >;
}

export interface TaxUpdateDataInput {
  taxType?: Maybe<String>;
  taxPercentage?: Maybe<Float>;
}

export interface ShoppingCartUpdateManyMutationInput {
  cartId?: Maybe<String>;
  attributes?: Maybe<String>;
  quantity?: Maybe<Int>;
  buyNow?: Maybe<Boolean>;
  addedOn?: Maybe<String>;
}

export interface AttributeUpsertNestedInput {
  update: AttributeUpdateDataInput;
  create: AttributeCreateInput;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface AttributeValueUpdateManyMutationInput {
  value?: Maybe<String>;
}

export interface ShippingUpdateInput {
  shippingType?: Maybe<String>;
  shippingCost?: Maybe<Float>;
  shippingRegion?: Maybe<ShippingRegionUpdateOneRequiredInput>;
}

export interface AuditCreateInput {
  id?: Maybe<Int>;
  order: OrderCreateOneInput;
  createdOn: String;
  message: String;
  code: Int;
}

export interface OrderDetailWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  order?: Maybe<OrderWhereInput>;
  product?: Maybe<ProductWhereInput>;
  attributes?: Maybe<String>;
  attributes_not?: Maybe<String>;
  attributes_in?: Maybe<String[] | String>;
  attributes_not_in?: Maybe<String[] | String>;
  attributes_lt?: Maybe<String>;
  attributes_lte?: Maybe<String>;
  attributes_gt?: Maybe<String>;
  attributes_gte?: Maybe<String>;
  attributes_contains?: Maybe<String>;
  attributes_not_contains?: Maybe<String>;
  attributes_starts_with?: Maybe<String>;
  attributes_not_starts_with?: Maybe<String>;
  attributes_ends_with?: Maybe<String>;
  attributes_not_ends_with?: Maybe<String>;
  productName?: Maybe<String>;
  productName_not?: Maybe<String>;
  productName_in?: Maybe<String[] | String>;
  productName_not_in?: Maybe<String[] | String>;
  productName_lt?: Maybe<String>;
  productName_lte?: Maybe<String>;
  productName_gt?: Maybe<String>;
  productName_gte?: Maybe<String>;
  productName_contains?: Maybe<String>;
  productName_not_contains?: Maybe<String>;
  productName_starts_with?: Maybe<String>;
  productName_not_starts_with?: Maybe<String>;
  productName_ends_with?: Maybe<String>;
  productName_not_ends_with?: Maybe<String>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  unitCost?: Maybe<Float>;
  unitCost_not?: Maybe<Float>;
  unitCost_in?: Maybe<Float[] | Float>;
  unitCost_not_in?: Maybe<Float[] | Float>;
  unitCost_lt?: Maybe<Float>;
  unitCost_lte?: Maybe<Float>;
  unitCost_gt?: Maybe<Float>;
  unitCost_gte?: Maybe<Float>;
  AND?: Maybe<OrderDetailWhereInput[] | OrderDetailWhereInput>;
  OR?: Maybe<OrderDetailWhereInput[] | OrderDetailWhereInput>;
  NOT?: Maybe<OrderDetailWhereInput[] | OrderDetailWhereInput>;
}

export interface OrderCreateOneInput {
  create?: Maybe<OrderCreateInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface OrderCreateInput {
  id?: Maybe<Int>;
  totalAmount: Float;
  createdOn: String;
  shippedOn: String;
  status: Int;
  comments?: Maybe<String>;
  customer?: Maybe<CustomerCreateOneInput>;
  authCode?: Maybe<String>;
  reference?: Maybe<String>;
  shipping?: Maybe<ShippingCreateOneInput>;
  tax?: Maybe<TaxCreateOneInput>;
}

export interface CategoryUpdateOneRequiredInput {
  create?: Maybe<CategoryCreateInput>;
  update?: Maybe<CategoryUpdateDataInput>;
  upsert?: Maybe<CategoryUpsertNestedInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CustomerCreateOneInput {
  create?: Maybe<CustomerCreateInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface ProductCategoryCreateInput {
  id?: Maybe<Int>;
  product: ProductCreateOneInput;
  category: CategoryCreateOneInput;
}

export interface CustomerCreateInput {
  id?: Maybe<Int>;
  name: String;
  email: String;
  password: String;
  creditCard?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
  shippingRegion: ShippingRegionCreateOneInput;
  dayPhone?: Maybe<String>;
  evePhone?: Maybe<String>;
  mobPhone?: Maybe<String>;
}

export interface AttributeValueUpdateOneRequiredInput {
  create?: Maybe<AttributeValueCreateInput>;
  update?: Maybe<AttributeValueUpdateDataInput>;
  upsert?: Maybe<AttributeValueUpsertNestedInput>;
  connect?: Maybe<AttributeValueWhereUniqueInput>;
}

export interface ShippingRegionCreateOneInput {
  create?: Maybe<ShippingRegionCreateInput>;
  connect?: Maybe<ShippingRegionWhereUniqueInput>;
}

export interface ProductCategoryWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  product?: Maybe<ProductWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  AND?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
  OR?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
  NOT?: Maybe<ProductCategoryWhereInput[] | ProductCategoryWhereInput>;
}

export interface ShippingRegionCreateInput {
  id?: Maybe<Int>;
  shippingRegion: String;
}

export interface TaxSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TaxWhereInput>;
  AND?: Maybe<TaxSubscriptionWhereInput[] | TaxSubscriptionWhereInput>;
  OR?: Maybe<TaxSubscriptionWhereInput[] | TaxSubscriptionWhereInput>;
  NOT?: Maybe<TaxSubscriptionWhereInput[] | TaxSubscriptionWhereInput>;
}

export interface TaxUpdateOneInput {
  create?: Maybe<TaxCreateInput>;
  update?: Maybe<TaxUpdateDataInput>;
  upsert?: Maybe<TaxUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TaxWhereUniqueInput>;
}

export interface ShippingRegionWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  shippingRegion?: Maybe<String>;
  shippingRegion_not?: Maybe<String>;
  shippingRegion_in?: Maybe<String[] | String>;
  shippingRegion_not_in?: Maybe<String[] | String>;
  shippingRegion_lt?: Maybe<String>;
  shippingRegion_lte?: Maybe<String>;
  shippingRegion_gt?: Maybe<String>;
  shippingRegion_gte?: Maybe<String>;
  shippingRegion_contains?: Maybe<String>;
  shippingRegion_not_contains?: Maybe<String>;
  shippingRegion_starts_with?: Maybe<String>;
  shippingRegion_not_starts_with?: Maybe<String>;
  shippingRegion_ends_with?: Maybe<String>;
  shippingRegion_not_ends_with?: Maybe<String>;
  AND?: Maybe<ShippingRegionWhereInput[] | ShippingRegionWhereInput>;
  OR?: Maybe<ShippingRegionWhereInput[] | ShippingRegionWhereInput>;
  NOT?: Maybe<ShippingRegionWhereInput[] | ShippingRegionWhereInput>;
}

export interface ShippingCreateInput {
  id?: Maybe<Int>;
  shippingType: String;
  shippingCost: Float;
  shippingRegion: ShippingRegionCreateOneInput;
}

export interface OrderDetailSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderDetailWhereInput>;
  AND?: Maybe<
    OrderDetailSubscriptionWhereInput[] | OrderDetailSubscriptionWhereInput
  >;
  OR?: Maybe<
    OrderDetailSubscriptionWhereInput[] | OrderDetailSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OrderDetailSubscriptionWhereInput[] | OrderDetailSubscriptionWhereInput
  >;
}

export interface TaxCreateOneInput {
  create?: Maybe<TaxCreateInput>;
  connect?: Maybe<TaxWhereUniqueInput>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface TaxCreateInput {
  id?: Maybe<Int>;
  taxType: String;
  taxPercentage: Float;
}

export interface ShoppingCartCreateInput {
  id?: Maybe<Int>;
  cartId: String;
  product: ProductCreateOneInput;
  attributes: String;
  quantity: Int;
  buyNow: Boolean;
  addedOn: String;
}

export interface AuditUpdateInput {
  order?: Maybe<OrderUpdateOneRequiredInput>;
  createdOn?: Maybe<String>;
  message?: Maybe<String>;
  code?: Maybe<Int>;
}

export interface ReviewUpdateManyMutationInput {
  review?: Maybe<String>;
  rating?: Maybe<Int>;
  created_On?: Maybe<String>;
}

export interface OrderUpdateOneRequiredInput {
  create?: Maybe<OrderCreateInput>;
  update?: Maybe<OrderUpdateDataInput>;
  upsert?: Maybe<OrderUpsertNestedInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface OrderUpdateDataInput {
  totalAmount?: Maybe<Float>;
  createdOn?: Maybe<String>;
  shippedOn?: Maybe<String>;
  status?: Maybe<Int>;
  comments?: Maybe<String>;
  customer?: Maybe<CustomerUpdateOneInput>;
  authCode?: Maybe<String>;
  reference?: Maybe<String>;
  shipping?: Maybe<ShippingUpdateOneInput>;
  tax?: Maybe<TaxUpdateOneInput>;
}

export interface AttributeValueUpsertNestedInput {
  update: AttributeValueUpdateDataInput;
  create: AttributeValueCreateInput;
}

export interface CustomerUpdateOneInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  price?: Maybe<Float>;
  discountedPrice?: Maybe<Float>;
  image?: Maybe<String>;
  image2?: Maybe<String>;
  thumbnail?: Maybe<String>;
  display?: Maybe<Int>;
}

export interface CustomerUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  creditCard?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  postalCode?: Maybe<String>;
  country?: Maybe<String>;
  shippingRegion?: Maybe<ShippingRegionUpdateOneRequiredInput>;
  dayPhone?: Maybe<String>;
  evePhone?: Maybe<String>;
  mobPhone?: Maybe<String>;
}

export interface ProductCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductCategoryWhereInput>;
  AND?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductCategorySubscriptionWhereInput[]
    | ProductCategorySubscriptionWhereInput
  >;
}

export interface ShippingRegionUpdateOneRequiredInput {
  create?: Maybe<ShippingRegionCreateInput>;
  update?: Maybe<ShippingRegionUpdateDataInput>;
  upsert?: Maybe<ShippingRegionUpsertNestedInput>;
  connect?: Maybe<ShippingRegionWhereUniqueInput>;
}

export interface TaxUpdateInput {
  taxType?: Maybe<String>;
  taxPercentage?: Maybe<Float>;
}

export interface ShippingRegionUpdateDataInput {
  shippingRegion?: Maybe<String>;
}

export interface ReviewUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  product?: Maybe<ProductUpdateOneRequiredInput>;
  review?: Maybe<String>;
  rating?: Maybe<Int>;
  created_On?: Maybe<String>;
}

export interface ShippingUpdateDataInput {
  shippingType?: Maybe<String>;
  shippingCost?: Maybe<Float>;
  shippingRegion?: Maybe<ShippingRegionUpdateOneRequiredInput>;
}

export interface ShippingUpdateOneInput {
  create?: Maybe<ShippingCreateInput>;
  update?: Maybe<ShippingUpdateDataInput>;
  upsert?: Maybe<ShippingUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShippingWhereUniqueInput>;
}

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface ShippingRegionUpsertNestedInput {
  update: ShippingRegionUpdateDataInput;
  create: ShippingRegionCreateInput;
}

export interface CategoryCreateOneInput {
  create?: Maybe<CategoryCreateInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface ShippingRegionUpdateInput {
  shippingRegion?: Maybe<String>;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewWhereInput>;
  AND?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  OR?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  NOT?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
}

export type ProductCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface TaxPreviousValues {
  id: Int;
  taxType: String;
  taxPercentage: Float;
}

export interface TaxPreviousValuesPromise
  extends Promise<TaxPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  taxType: () => Promise<String>;
  taxPercentage: () => Promise<Float>;
}

export interface TaxPreviousValuesSubscription
  extends Promise<AsyncIterator<TaxPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  taxType: () => Promise<AsyncIterator<String>>;
  taxPercentage: () => Promise<AsyncIterator<Float>>;
}

export interface AttributeValueConnection {
  pageInfo: PageInfo;
  edges: AttributeValueEdge[];
}

export interface AttributeValueConnectionPromise
  extends Promise<AttributeValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributeValueEdge>>() => T;
  aggregate: <T = AggregateAttributeValuePromise>() => T;
}

export interface AttributeValueConnectionSubscription
  extends Promise<AsyncIterator<AttributeValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributeValueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributeValueSubscription>() => T;
}

export interface Audit {
  id: Int;
  createdOn: String;
  message: String;
  code: Int;
}

export interface AuditPromise extends Promise<Audit>, Fragmentable {
  id: () => Promise<Int>;
  order: <T = OrderPromise>() => T;
  createdOn: () => Promise<String>;
  message: () => Promise<String>;
  code: () => Promise<Int>;
}

export interface AuditSubscription
  extends Promise<AsyncIterator<Audit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  order: <T = OrderSubscription>() => T;
  createdOn: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<Int>>;
}

export interface AuditNullablePromise
  extends Promise<Audit | null>,
    Fragmentable {
  id: () => Promise<Int>;
  order: <T = OrderPromise>() => T;
  createdOn: () => Promise<String>;
  message: () => Promise<String>;
  code: () => Promise<Int>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Order {
  id: Int;
  totalAmount: Float;
  createdOn: String;
  shippedOn: String;
  status: Int;
  comments?: String;
  authCode?: String;
  reference?: String;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<Int>;
  totalAmount: () => Promise<Float>;
  createdOn: () => Promise<String>;
  shippedOn: () => Promise<String>;
  status: () => Promise<Int>;
  comments: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
  authCode: () => Promise<String>;
  reference: () => Promise<String>;
  shipping: <T = ShippingPromise>() => T;
  tax: <T = TaxPromise>() => T;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  totalAmount: () => Promise<AsyncIterator<Float>>;
  createdOn: () => Promise<AsyncIterator<String>>;
  shippedOn: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  comments: () => Promise<AsyncIterator<String>>;
  customer: <T = CustomerSubscription>() => T;
  authCode: () => Promise<AsyncIterator<String>>;
  reference: () => Promise<AsyncIterator<String>>;
  shipping: <T = ShippingSubscription>() => T;
  tax: <T = TaxSubscription>() => T;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<Int>;
  totalAmount: () => Promise<Float>;
  createdOn: () => Promise<String>;
  shippedOn: () => Promise<String>;
  status: () => Promise<Int>;
  comments: () => Promise<String>;
  customer: <T = CustomerPromise>() => T;
  authCode: () => Promise<String>;
  reference: () => Promise<String>;
  shipping: <T = ShippingPromise>() => T;
  tax: <T = TaxPromise>() => T;
}

export interface ShoppingCartSubscriptionPayload {
  mutation: MutationType;
  node: ShoppingCart;
  updatedFields: String[];
  previousValues: ShoppingCartPreviousValues;
}

export interface ShoppingCartSubscriptionPayloadPromise
  extends Promise<ShoppingCartSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShoppingCartPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShoppingCartPreviousValuesPromise>() => T;
}

export interface ShoppingCartSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShoppingCartSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShoppingCartSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShoppingCartPreviousValuesSubscription>() => T;
}

export interface Customer {
  id: Int;
  name: String;
  email: String;
  password: String;
  creditCard?: String;
  address1?: String;
  address2?: String;
  city?: String;
  region?: String;
  postalCode?: String;
  country?: String;
  dayPhone?: String;
  evePhone?: String;
  mobPhone?: String;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  creditCard: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
  shippingRegion: <T = ShippingRegionPromise>() => T;
  dayPhone: () => Promise<String>;
  evePhone: () => Promise<String>;
  mobPhone: () => Promise<String>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  creditCard: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  shippingRegion: <T = ShippingRegionSubscription>() => T;
  dayPhone: () => Promise<AsyncIterator<String>>;
  evePhone: () => Promise<AsyncIterator<String>>;
  mobPhone: () => Promise<AsyncIterator<String>>;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  creditCard: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
  shippingRegion: <T = ShippingRegionPromise>() => T;
  dayPhone: () => Promise<String>;
  evePhone: () => Promise<String>;
  mobPhone: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTax {
  count: Int;
}

export interface AggregateTaxPromise
  extends Promise<AggregateTax>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTaxSubscription
  extends Promise<AsyncIterator<AggregateTax>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TaxConnection {
  pageInfo: PageInfo;
  edges: TaxEdge[];
}

export interface TaxConnectionPromise
  extends Promise<TaxConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TaxEdge>>() => T;
  aggregate: <T = AggregateTaxPromise>() => T;
}

export interface TaxConnectionSubscription
  extends Promise<AsyncIterator<TaxConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TaxEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTaxSubscription>() => T;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface AggregateShoppingCart {
  count: Int;
}

export interface AggregateShoppingCartPromise
  extends Promise<AggregateShoppingCart>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShoppingCartSubscription
  extends Promise<AsyncIterator<AggregateShoppingCart>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Attribute {
  id: Int;
  name: String;
}

export interface AttributePromise extends Promise<Attribute>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface AttributeSubscription
  extends Promise<AsyncIterator<Attribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AttributeNullablePromise
  extends Promise<Attribute | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ShoppingCartConnection {
  pageInfo: PageInfo;
  edges: ShoppingCartEdge[];
}

export interface ShoppingCartConnectionPromise
  extends Promise<ShoppingCartConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShoppingCartEdge>>() => T;
  aggregate: <T = AggregateShoppingCartPromise>() => T;
}

export interface ShoppingCartConnectionSubscription
  extends Promise<AsyncIterator<ShoppingCartConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShoppingCartEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShoppingCartSubscription>() => T;
}

export interface AttributeSubscriptionPayload {
  mutation: MutationType;
  node: Attribute;
  updatedFields: String[];
  previousValues: AttributePreviousValues;
}

export interface AttributeSubscriptionPayloadPromise
  extends Promise<AttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributePreviousValuesPromise>() => T;
}

export interface AttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributePreviousValuesSubscription>() => T;
}

export interface AggregateShippingRegion {
  count: Int;
}

export interface AggregateShippingRegionPromise
  extends Promise<AggregateShippingRegion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShippingRegionSubscription
  extends Promise<AsyncIterator<AggregateShippingRegion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttributePreviousValues {
  id: Int;
  name: String;
}

export interface AttributePreviousValuesPromise
  extends Promise<AttributePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface AttributePreviousValuesSubscription
  extends Promise<AsyncIterator<AttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ShippingRegionConnection {
  pageInfo: PageInfo;
  edges: ShippingRegionEdge[];
}

export interface ShippingRegionConnectionPromise
  extends Promise<ShippingRegionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShippingRegionEdge>>() => T;
  aggregate: <T = AggregateShippingRegionPromise>() => T;
}

export interface ShippingRegionConnectionSubscription
  extends Promise<AsyncIterator<ShippingRegionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShippingRegionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShippingRegionSubscription>() => T;
}

export interface AttributeValueEdge {
  node: AttributeValue;
  cursor: String;
}

export interface AttributeValueEdgePromise
  extends Promise<AttributeValueEdge>,
    Fragmentable {
  node: <T = AttributeValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributeValueEdgeSubscription
  extends Promise<AsyncIterator<AttributeValueEdge>>,
    Fragmentable {
  node: <T = AttributeValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShipping {
  count: Int;
}

export interface AggregateShippingPromise
  extends Promise<AggregateShipping>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShippingSubscription
  extends Promise<AsyncIterator<AggregateShipping>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttributeValueSubscriptionPayload {
  mutation: MutationType;
  node: AttributeValue;
  updatedFields: String[];
  previousValues: AttributeValuePreviousValues;
}

export interface AttributeValueSubscriptionPayloadPromise
  extends Promise<AttributeValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributeValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributeValuePreviousValuesPromise>() => T;
}

export interface AttributeValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributeValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributeValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributeValuePreviousValuesSubscription>() => T;
}

export interface ShippingConnection {
  pageInfo: PageInfo;
  edges: ShippingEdge[];
}

export interface ShippingConnectionPromise
  extends Promise<ShippingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShippingEdge>>() => T;
  aggregate: <T = AggregateShippingPromise>() => T;
}

export interface ShippingConnectionSubscription
  extends Promise<AsyncIterator<ShippingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShippingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShippingSubscription>() => T;
}

export interface AttributeValuePreviousValues {
  id: Int;
  value: String;
}

export interface AttributeValuePreviousValuesPromise
  extends Promise<AttributeValuePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  value: () => Promise<String>;
}

export interface AttributeValuePreviousValuesSubscription
  extends Promise<AsyncIterator<AttributeValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface AuditSubscriptionPayload {
  mutation: MutationType;
  node: Audit;
  updatedFields: String[];
  previousValues: AuditPreviousValues;
}

export interface AuditSubscriptionPayloadPromise
  extends Promise<AuditSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuditPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuditPreviousValuesPromise>() => T;
}

export interface AuditSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuditSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuditSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuditPreviousValuesSubscription>() => T;
}

export interface Review {
  id: Int;
  review: String;
  rating: Int;
  created_On: String;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<Int>;
  customer: <T = CustomerPromise>() => T;
  product: <T = ProductPromise>() => T;
  review: () => Promise<String>;
  rating: () => Promise<Int>;
  created_On: () => Promise<String>;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  customer: <T = CustomerSubscription>() => T;
  product: <T = ProductSubscription>() => T;
  review: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Int>>;
  created_On: () => Promise<AsyncIterator<String>>;
}

export interface ReviewNullablePromise
  extends Promise<Review | null>,
    Fragmentable {
  id: () => Promise<Int>;
  customer: <T = CustomerPromise>() => T;
  product: <T = ProductPromise>() => T;
  review: () => Promise<String>;
  rating: () => Promise<Int>;
  created_On: () => Promise<String>;
}

export interface AuditPreviousValues {
  id: Int;
  createdOn: String;
  message: String;
  code: Int;
}

export interface AuditPreviousValuesPromise
  extends Promise<AuditPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdOn: () => Promise<String>;
  message: () => Promise<String>;
  code: () => Promise<Int>;
}

export interface AuditPreviousValuesSubscription
  extends Promise<AsyncIterator<AuditPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdOn: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<Int>>;
}

export interface ProductCategoryEdge {
  node: ProductCategory;
  cursor: String;
}

export interface ProductCategoryEdgePromise
  extends Promise<ProductCategoryEdge>,
    Fragmentable {
  node: <T = ProductCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductCategoryEdgeSubscription
  extends Promise<AsyncIterator<ProductCategoryEdge>>,
    Fragmentable {
  node: <T = ProductCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttributeEdge {
  node: Attribute;
  cursor: String;
}

export interface AttributeEdgePromise
  extends Promise<AttributeEdge>,
    Fragmentable {
  node: <T = AttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributeEdgeSubscription
  extends Promise<AsyncIterator<AttributeEdge>>,
    Fragmentable {
  node: <T = AttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface AggregateProductAttribute {
  count: Int;
}

export interface AggregateProductAttributePromise
  extends Promise<AggregateProductAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductAttributeSubscription
  extends Promise<AsyncIterator<AggregateProductAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryPreviousValues {
  id: Int;
  name: String;
  description?: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProductAttributeConnection {
  pageInfo: PageInfo;
  edges: ProductAttributeEdge[];
}

export interface ProductAttributeConnectionPromise
  extends Promise<ProductAttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductAttributeEdge>>() => T;
  aggregate: <T = AggregateProductAttributePromise>() => T;
}

export interface ProductAttributeConnectionSubscription
  extends Promise<AsyncIterator<ProductAttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductAttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductAttributeSubscription>() => T;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface ProductAttribute {
  id: Int;
}

export interface ProductAttributePromise
  extends Promise<ProductAttribute>,
    Fragmentable {
  id: () => Promise<Int>;
  product: <T = ProductPromise>() => T;
  attributeValue: <T = AttributeValuePromise>() => T;
}

export interface ProductAttributeSubscription
  extends Promise<AsyncIterator<ProductAttribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  product: <T = ProductSubscription>() => T;
  attributeValue: <T = AttributeValueSubscription>() => T;
}

export interface ProductAttributeNullablePromise
  extends Promise<ProductAttribute | null>,
    Fragmentable {
  id: () => Promise<Int>;
  product: <T = ProductPromise>() => T;
  attributeValue: <T = AttributeValuePromise>() => T;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerPreviousValues {
  id: Int;
  name: String;
  email: String;
  password: String;
  creditCard?: String;
  address1?: String;
  address2?: String;
  city?: String;
  region?: String;
  postalCode?: String;
  country?: String;
  dayPhone?: String;
  evePhone?: String;
  mobPhone?: String;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  creditCard: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
  dayPhone: () => Promise<String>;
  evePhone: () => Promise<String>;
  mobPhone: () => Promise<String>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  creditCard: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  dayPhone: () => Promise<AsyncIterator<String>>;
  evePhone: () => Promise<AsyncIterator<String>>;
  mobPhone: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderDetail {
  count: Int;
}

export interface AggregateOrderDetailPromise
  extends Promise<AggregateOrderDetail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderDetailSubscription
  extends Promise<AsyncIterator<AggregateOrderDetail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAttributeValue {
  count: Int;
}

export interface AggregateAttributeValuePromise
  extends Promise<AggregateAttributeValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributeValueSubscription
  extends Promise<AsyncIterator<AggregateAttributeValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderDetailConnection {
  pageInfo: PageInfo;
  edges: OrderDetailEdge[];
}

export interface OrderDetailConnectionPromise
  extends Promise<OrderDetailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderDetailEdge>>() => T;
  aggregate: <T = AggregateOrderDetailPromise>() => T;
}

export interface OrderDetailConnectionSubscription
  extends Promise<AsyncIterator<OrderDetailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderDetailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderDetailSubscription>() => T;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface Product {
  id: Int;
  name: String;
  description: String;
  price: Float;
  discountedPrice: Float;
  image?: String;
  image2?: String;
  thumbnail?: String;
  display: Int;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  discountedPrice: () => Promise<Float>;
  image: () => Promise<String>;
  image2: () => Promise<String>;
  thumbnail: () => Promise<String>;
  display: () => Promise<Int>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  discountedPrice: () => Promise<AsyncIterator<Float>>;
  image: () => Promise<AsyncIterator<String>>;
  image2: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  display: () => Promise<AsyncIterator<Int>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  discountedPrice: () => Promise<Float>;
  image: () => Promise<String>;
  image2: () => Promise<String>;
  thumbnail: () => Promise<String>;
  display: () => Promise<Int>;
}

export interface DepartmentPreviousValues {
  id: Int;
  name: String;
  description?: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Department {
  id: Int;
  name: String;
  description?: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderPreviousValues {
  id: Int;
  totalAmount: Float;
  createdOn: String;
  shippedOn: String;
  status: Int;
  comments?: String;
  authCode?: String;
  reference?: String;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  totalAmount: () => Promise<Float>;
  createdOn: () => Promise<String>;
  shippedOn: () => Promise<String>;
  status: () => Promise<Int>;
  comments: () => Promise<String>;
  authCode: () => Promise<String>;
  reference: () => Promise<String>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  totalAmount: () => Promise<AsyncIterator<Float>>;
  createdOn: () => Promise<AsyncIterator<String>>;
  shippedOn: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  comments: () => Promise<AsyncIterator<String>>;
  authCode: () => Promise<AsyncIterator<String>>;
  reference: () => Promise<AsyncIterator<String>>;
}

export interface TaxEdge {
  node: Tax;
  cursor: String;
}

export interface TaxEdgePromise extends Promise<TaxEdge>, Fragmentable {
  node: <T = TaxPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TaxEdgeSubscription
  extends Promise<AsyncIterator<TaxEdge>>,
    Fragmentable {
  node: <T = TaxSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Category {
  id: Int;
  name: String;
  description?: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<Int>;
  department: <T = DepartmentPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  department: <T = DepartmentSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<Int>;
  department: <T = DepartmentPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ShoppingCartEdge {
  node: ShoppingCart;
  cursor: String;
}

export interface ShoppingCartEdgePromise
  extends Promise<ShoppingCartEdge>,
    Fragmentable {
  node: <T = ShoppingCartPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShoppingCartEdgeSubscription
  extends Promise<AsyncIterator<ShoppingCartEdge>>,
    Fragmentable {
  node: <T = ShoppingCartSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderDetailSubscriptionPayload {
  mutation: MutationType;
  node: OrderDetail;
  updatedFields: String[];
  previousValues: OrderDetailPreviousValues;
}

export interface OrderDetailSubscriptionPayloadPromise
  extends Promise<OrderDetailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderDetailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderDetailPreviousValuesPromise>() => T;
}

export interface OrderDetailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderDetailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderDetailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderDetailPreviousValuesSubscription>() => T;
}

export interface ShippingRegionEdge {
  node: ShippingRegion;
  cursor: String;
}

export interface ShippingRegionEdgePromise
  extends Promise<ShippingRegionEdge>,
    Fragmentable {
  node: <T = ShippingRegionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShippingRegionEdgeSubscription
  extends Promise<AsyncIterator<ShippingRegionEdge>>,
    Fragmentable {
  node: <T = ShippingRegionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderDetailPreviousValues {
  id: Int;
  attributes: String;
  productName: String;
  quantity: Int;
  unitCost: Float;
}

export interface OrderDetailPreviousValuesPromise
  extends Promise<OrderDetailPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  attributes: () => Promise<String>;
  productName: () => Promise<String>;
  quantity: () => Promise<Int>;
  unitCost: () => Promise<Float>;
}

export interface OrderDetailPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderDetailPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  attributes: () => Promise<AsyncIterator<String>>;
  productName: () => Promise<AsyncIterator<String>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  unitCost: () => Promise<AsyncIterator<Float>>;
}

export interface ShippingEdge {
  node: Shipping;
  cursor: String;
}

export interface ShippingEdgePromise
  extends Promise<ShippingEdge>,
    Fragmentable {
  node: <T = ShippingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShippingEdgeSubscription
  extends Promise<AsyncIterator<ShippingEdge>>,
    Fragmentable {
  node: <T = ShippingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAudit {
  count: Int;
}

export interface AggregateAuditPromise
  extends Promise<AggregateAudit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuditSubscription
  extends Promise<AsyncIterator<AggregateAudit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface AggregateProductCategory {
  count: Int;
}

export interface AggregateProductCategoryPromise
  extends Promise<AggregateProductCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductCategorySubscription
  extends Promise<AsyncIterator<AggregateProductCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductPreviousValues {
  id: Int;
  name: String;
  description: String;
  price: Float;
  discountedPrice: Float;
  image?: String;
  image2?: String;
  thumbnail?: String;
  display: Int;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  discountedPrice: () => Promise<Float>;
  image: () => Promise<String>;
  image2: () => Promise<String>;
  thumbnail: () => Promise<String>;
  display: () => Promise<Int>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  discountedPrice: () => Promise<AsyncIterator<Float>>;
  image: () => Promise<AsyncIterator<String>>;
  image2: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  display: () => Promise<AsyncIterator<Int>>;
}

export interface ProductCategory {
  id: Int;
}

export interface ProductCategoryPromise
  extends Promise<ProductCategory>,
    Fragmentable {
  id: () => Promise<Int>;
  product: <T = ProductPromise>() => T;
  category: <T = CategoryPromise>() => T;
}

export interface ProductCategorySubscription
  extends Promise<AsyncIterator<ProductCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  product: <T = ProductSubscription>() => T;
  category: <T = CategorySubscription>() => T;
}

export interface ProductCategoryNullablePromise
  extends Promise<ProductCategory | null>,
    Fragmentable {
  id: () => Promise<Int>;
  product: <T = ProductPromise>() => T;
  category: <T = CategoryPromise>() => T;
}

export interface AuditEdge {
  node: Audit;
  cursor: String;
}

export interface AuditEdgePromise extends Promise<AuditEdge>, Fragmentable {
  node: <T = AuditPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuditEdgeSubscription
  extends Promise<AsyncIterator<AuditEdge>>,
    Fragmentable {
  node: <T = AuditSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAttribute {
  count: Int;
}

export interface AggregateAttributePromise
  extends Promise<AggregateAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributeSubscription
  extends Promise<AsyncIterator<AggregateAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductAttributeSubscriptionPayload {
  mutation: MutationType;
  node: ProductAttribute;
  updatedFields: String[];
  previousValues: ProductAttributePreviousValues;
}

export interface ProductAttributeSubscriptionPayloadPromise
  extends Promise<ProductAttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductAttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductAttributePreviousValuesPromise>() => T;
}

export interface ProductAttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductAttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductAttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductAttributePreviousValuesSubscription>() => T;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductAttributePreviousValues {
  id: Int;
}

export interface ProductAttributePreviousValuesPromise
  extends Promise<ProductAttributePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
}

export interface ProductAttributePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductAttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
}

export interface AttributeValue {
  id: Int;
  value: String;
}

export interface AttributeValuePromise
  extends Promise<AttributeValue>,
    Fragmentable {
  id: () => Promise<Int>;
  attribute: <T = AttributePromise>() => T;
  value: () => Promise<String>;
}

export interface AttributeValueSubscription
  extends Promise<AsyncIterator<AttributeValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  attribute: <T = AttributeSubscription>() => T;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AttributeValueNullablePromise
  extends Promise<AttributeValue | null>,
    Fragmentable {
  id: () => Promise<Int>;
  attribute: <T = AttributePromise>() => T;
  value: () => Promise<String>;
}

export interface AuditConnection {
  pageInfo: PageInfo;
  edges: AuditEdge[];
}

export interface AuditConnectionPromise
  extends Promise<AuditConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuditEdge>>() => T;
  aggregate: <T = AggregateAuditPromise>() => T;
}

export interface AuditConnectionSubscription
  extends Promise<AsyncIterator<AuditConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuditEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuditSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductCategorySubscriptionPayload {
  mutation: MutationType;
  node: ProductCategory;
  updatedFields: String[];
  previousValues: ProductCategoryPreviousValues;
}

export interface ProductCategorySubscriptionPayloadPromise
  extends Promise<ProductCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductCategoryPreviousValuesPromise>() => T;
}

export interface ProductCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductCategoryPreviousValuesSubscription>() => T;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface ProductCategoryPreviousValues {
  id: Int;
}

export interface ProductCategoryPreviousValuesPromise
  extends Promise<ProductCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
}

export interface ProductCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
}

export interface ShoppingCart {
  id: Int;
  cartId: String;
  attributes: String;
  quantity: Int;
  buyNow: Boolean;
  addedOn: String;
}

export interface ShoppingCartPromise
  extends Promise<ShoppingCart>,
    Fragmentable {
  id: () => Promise<Int>;
  cartId: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  attributes: () => Promise<String>;
  quantity: () => Promise<Int>;
  buyNow: () => Promise<Boolean>;
  addedOn: () => Promise<String>;
}

export interface ShoppingCartSubscription
  extends Promise<AsyncIterator<ShoppingCart>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cartId: () => Promise<AsyncIterator<String>>;
  product: <T = ProductSubscription>() => T;
  attributes: () => Promise<AsyncIterator<String>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  buyNow: () => Promise<AsyncIterator<Boolean>>;
  addedOn: () => Promise<AsyncIterator<String>>;
}

export interface ShoppingCartNullablePromise
  extends Promise<ShoppingCart | null>,
    Fragmentable {
  id: () => Promise<Int>;
  cartId: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  attributes: () => Promise<String>;
  quantity: () => Promise<Int>;
  buyNow: () => Promise<Boolean>;
  addedOn: () => Promise<String>;
}

export interface Tax {
  id: Int;
  taxType: String;
  taxPercentage: Float;
}

export interface TaxPromise extends Promise<Tax>, Fragmentable {
  id: () => Promise<Int>;
  taxType: () => Promise<String>;
  taxPercentage: () => Promise<Float>;
}

export interface TaxSubscription
  extends Promise<AsyncIterator<Tax>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  taxType: () => Promise<AsyncIterator<String>>;
  taxPercentage: () => Promise<AsyncIterator<Float>>;
}

export interface TaxNullablePromise extends Promise<Tax | null>, Fragmentable {
  id: () => Promise<Int>;
  taxType: () => Promise<String>;
  taxPercentage: () => Promise<Float>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface ProductCategoryConnection {
  pageInfo: PageInfo;
  edges: ProductCategoryEdge[];
}

export interface ProductCategoryConnectionPromise
  extends Promise<ProductCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductCategoryEdge>>() => T;
  aggregate: <T = AggregateProductCategoryPromise>() => T;
}

export interface ProductCategoryConnectionSubscription
  extends Promise<AsyncIterator<ProductCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductCategorySubscription>() => T;
}

export interface ReviewPreviousValues {
  id: Int;
  review: String;
  rating: Int;
  created_On: String;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  review: () => Promise<String>;
  rating: () => Promise<Int>;
  created_On: () => Promise<String>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  review: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Int>>;
  created_On: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Shipping {
  id: Int;
  shippingType: String;
  shippingCost: Float;
}

export interface ShippingPromise extends Promise<Shipping>, Fragmentable {
  id: () => Promise<Int>;
  shippingType: () => Promise<String>;
  shippingCost: () => Promise<Float>;
  shippingRegion: <T = ShippingRegionPromise>() => T;
}

export interface ShippingSubscription
  extends Promise<AsyncIterator<Shipping>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  shippingType: () => Promise<AsyncIterator<String>>;
  shippingCost: () => Promise<AsyncIterator<Float>>;
  shippingRegion: <T = ShippingRegionSubscription>() => T;
}

export interface ShippingNullablePromise
  extends Promise<Shipping | null>,
    Fragmentable {
  id: () => Promise<Int>;
  shippingType: () => Promise<String>;
  shippingCost: () => Promise<Float>;
  shippingRegion: <T = ShippingRegionPromise>() => T;
}

export interface OrderDetail {
  id: Int;
  attributes: String;
  productName: String;
  quantity: Int;
  unitCost: Float;
}

export interface OrderDetailPromise extends Promise<OrderDetail>, Fragmentable {
  id: () => Promise<Int>;
  order: <T = OrderPromise>() => T;
  product: <T = ProductPromise>() => T;
  attributes: () => Promise<String>;
  productName: () => Promise<String>;
  quantity: () => Promise<Int>;
  unitCost: () => Promise<Float>;
}

export interface OrderDetailSubscription
  extends Promise<AsyncIterator<OrderDetail>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  order: <T = OrderSubscription>() => T;
  product: <T = ProductSubscription>() => T;
  attributes: () => Promise<AsyncIterator<String>>;
  productName: () => Promise<AsyncIterator<String>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  unitCost: () => Promise<AsyncIterator<Float>>;
}

export interface OrderDetailNullablePromise
  extends Promise<OrderDetail | null>,
    Fragmentable {
  id: () => Promise<Int>;
  order: <T = OrderPromise>() => T;
  product: <T = ProductPromise>() => T;
  attributes: () => Promise<String>;
  productName: () => Promise<String>;
  quantity: () => Promise<Int>;
  unitCost: () => Promise<Float>;
}

export interface ShippingSubscriptionPayload {
  mutation: MutationType;
  node: Shipping;
  updatedFields: String[];
  previousValues: ShippingPreviousValues;
}

export interface ShippingSubscriptionPayloadPromise
  extends Promise<ShippingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShippingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShippingPreviousValuesPromise>() => T;
}

export interface ShippingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShippingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShippingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShippingPreviousValuesSubscription>() => T;
}

export interface TaxSubscriptionPayload {
  mutation: MutationType;
  node: Tax;
  updatedFields: String[];
  previousValues: TaxPreviousValues;
}

export interface TaxSubscriptionPayloadPromise
  extends Promise<TaxSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TaxPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TaxPreviousValuesPromise>() => T;
}

export interface TaxSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TaxSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TaxSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TaxPreviousValuesSubscription>() => T;
}

export interface ShoppingCartPreviousValues {
  id: Int;
  cartId: String;
  attributes: String;
  quantity: Int;
  buyNow: Boolean;
  addedOn: String;
}

export interface ShoppingCartPreviousValuesPromise
  extends Promise<ShoppingCartPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  cartId: () => Promise<String>;
  attributes: () => Promise<String>;
  quantity: () => Promise<Int>;
  buyNow: () => Promise<Boolean>;
  addedOn: () => Promise<String>;
}

export interface ShoppingCartPreviousValuesSubscription
  extends Promise<AsyncIterator<ShoppingCartPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cartId: () => Promise<AsyncIterator<String>>;
  attributes: () => Promise<AsyncIterator<String>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  buyNow: () => Promise<AsyncIterator<Boolean>>;
  addedOn: () => Promise<AsyncIterator<String>>;
}

export interface ShippingRegionPreviousValues {
  id: Int;
  shippingRegion: String;
}

export interface ShippingRegionPreviousValuesPromise
  extends Promise<ShippingRegionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  shippingRegion: () => Promise<String>;
}

export interface ShippingRegionPreviousValuesSubscription
  extends Promise<AsyncIterator<ShippingRegionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  shippingRegion: () => Promise<AsyncIterator<String>>;
}

export interface ShippingRegionSubscriptionPayload {
  mutation: MutationType;
  node: ShippingRegion;
  updatedFields: String[];
  previousValues: ShippingRegionPreviousValues;
}

export interface ShippingRegionSubscriptionPayloadPromise
  extends Promise<ShippingRegionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShippingRegionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShippingRegionPreviousValuesPromise>() => T;
}

export interface ShippingRegionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShippingRegionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShippingRegionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShippingRegionPreviousValuesSubscription>() => T;
}

export interface ShippingRegion {
  id: Int;
  shippingRegion: String;
}

export interface ShippingRegionPromise
  extends Promise<ShippingRegion>,
    Fragmentable {
  id: () => Promise<Int>;
  shippingRegion: () => Promise<String>;
}

export interface ShippingRegionSubscription
  extends Promise<AsyncIterator<ShippingRegion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  shippingRegion: () => Promise<AsyncIterator<String>>;
}

export interface ShippingRegionNullablePromise
  extends Promise<ShippingRegion | null>,
    Fragmentable {
  id: () => Promise<Int>;
  shippingRegion: () => Promise<String>;
}

export interface ShippingPreviousValues {
  id: Int;
  shippingType: String;
  shippingCost: Float;
}

export interface ShippingPreviousValuesPromise
  extends Promise<ShippingPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  shippingType: () => Promise<String>;
  shippingCost: () => Promise<Float>;
}

export interface ShippingPreviousValuesSubscription
  extends Promise<AsyncIterator<ShippingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  shippingType: () => Promise<AsyncIterator<String>>;
  shippingCost: () => Promise<AsyncIterator<Float>>;
}

export interface ProductAttributeEdge {
  node: ProductAttribute;
  cursor: String;
}

export interface ProductAttributeEdgePromise
  extends Promise<ProductAttributeEdge>,
    Fragmentable {
  node: <T = ProductAttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductAttributeEdgeSubscription
  extends Promise<AsyncIterator<ProductAttributeEdge>>,
    Fragmentable {
  node: <T = ProductAttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttributeConnection {
  pageInfo: PageInfo;
  edges: AttributeEdge[];
}

export interface AttributeConnectionPromise
  extends Promise<AttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributeEdge>>() => T;
  aggregate: <T = AggregateAttributePromise>() => T;
}

export interface AttributeConnectionSubscription
  extends Promise<AsyncIterator<AttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributeSubscription>() => T;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderDetailEdge {
  node: OrderDetail;
  cursor: String;
}

export interface OrderDetailEdgePromise
  extends Promise<OrderDetailEdge>,
    Fragmentable {
  node: <T = OrderDetailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderDetailEdgeSubscription
  extends Promise<AsyncIterator<OrderDetailEdge>>,
    Fragmentable {
  node: <T = OrderDetailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Department",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductCategory",
    embedded: false
  },
  {
    name: "Attribute",
    embedded: false
  },
  {
    name: "AttributeValue",
    embedded: false
  },
  {
    name: "ProductAttribute",
    embedded: false
  },
  {
    name: "ShoppingCart",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "OrderDetail",
    embedded: false
  },
  {
    name: "ShippingRegion",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Shipping",
    embedded: false
  },
  {
    name: "Tax",
    embedded: false
  },
  {
    name: "Audit",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
